---
title: "Darwin Core checklist mapping"
subtitle: "For: Checklist title"
author:
- author_1
- author_2
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

# General setup 

LR: dit zijn stappen waaraan de gebruiker niets moet veranderen

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Use UTF-8 character encoding:
LR: Hier verschillende codering voor verschillende OS geven in handleiding:

```{r}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Install all required packages:
LR: dit staat hier eigenlijk niet goed, telkens als het script opnieuw wordt ingelezen worden deze packages ook geladen. Zou op een andere plek moeten komen.

```{r eval = FALSE}
install.packages(c("tidyverse", "magrittr", "readxl", "digest", "rgbif", "inborutils", "stringi"))
```

Load libraries:

```{r}
library(tidyverse)       # To transform data
library(magrittr)        # For %<>% pipes
library(janitor)         # To clean input data
library(readxl)          # To read Excel files
library(digest)          # To generate hashes
library(rgbif)
library(stringi)
```

Vectorize digest function to generate `taxonID`:
LR: dit eventueel onzichtbaar zetten

```{r}
vdigest <- Vectorize(digest)
```


# Read and pre-process raw data

Create a data frame `raw_data` from the source data `checklist.xlsx`:

```{r}
raw_data <- read_excel(path = "../data/raw/checklist.xlsx") 
```

Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```

# General quality check

Inspect first five rows in `raw_data`:

```{r}
raw_data %>% head(n = 5)
```

LR: eventueel ook tonen dat de datasets ten allertijde volledig kan worden opgevraagd in een nieuw venster:

```{r}
raw_data %>% View()
```

Basic cleaning steps:
LR: uitleggen in richtlijnen dat deze stap een extra cleaning step is, maar dat je basisdata in de template dus eigenlijk al clean moet zijn. 

```{r}
raw_data %<>%
  remove_empty("rows") %>%       # Remove empty rows
  clean_names()                  # Have sensible (lowercase) column names
```

Andere tools aan te rijken: eventueel verwijderen van dubbele spaties?

# Darwin Core mapping

## Generate taxon_ID:

LR: zal er vanaf hangen of er een taxonID nodig is of niet --> houden we hier rekening mee?.
Ook: Uitleggen in richlijnen waar informatie kan worden ingevuld. 

TaxonId moet gegenereerd worden op basis van een combinatie van de scientificname en kingdom om probleem met hemihomonymen te voorkomen.

```{r}
raw_data %<>% mutate(raw_taxon_id = paste(
  "dataset_shortname", 
  "taxon", 
  vdigest(paste(
    scientific_name, kingdom),  
  algo="md5"), sep=":"))
```


# Create taxon core

```{r}
taxon <- raw_data
```

## Pre-processing

LR: Uitleggen in richtlijnen dat elk taxon in de taxon core uniek moet zijn. Er mogen dus geen duplicaten inzitten. Dit is echter niet altijd het geval. ZO kan er voor 1 taxon meerdere distributie records aanwezig zijn. Of hemi-homonymen. Het is dus nodig om de dataset te inspecteren op homonymen.

Check for duplicates:

```{r}
duplicates <- taxon %>%  
  slice(which(duplicated(taxon $ raw_scientific_name) == "TRUE")) %>% 
  select(raw_scientific_name) 
```

```{r, echo=FALSE}
duplicates
```

Should contain zero rows.
If not: inspect dataset for more information on these species:

```{r}
taxon %>% filter(raw_scientific_name %in% duplicates $ raw_scientific_name)
```

LR: Wanneer de gedupliceerde scientific names verschillen in hun taxonomische/classificatie informatie: beiden worden gehouden in de taxon core. De taxonID moet wel verschillen tussen beide taxa, maar daarmee werd rekening gehouden bij het genereren van de taxonID (is op basis van scientific name en kingdom). Als de gedupliceerde taxa enkel verschillen in hun distributie informatie, dan kunnen we 1 van die records verwijderen in de taxon core.  
(zou je eventueel ook kunnen doen door bekijken van de taxonID's)

Remove duplicated rows:

```{r}
taxon %<>% slice(which(duplicated(taxon $ raw_scientific_name)==FALSE))
```

## Term mapping
 
Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

LR: aangeven dat dit de record-level terms zijn. Eventueel enkele voorbeelden aanrijken.

### language

```{r}
taxon %<>% mutate(language = "") 
```

### license

```{r}
taxon %<>% mutate(license = "") 
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "") 
```

### accessRights

```{r}
taxon %<>% mutate(accessRights = "") 
```

### datasetID

```{r}
taxon %<>% mutate(datasetID = "") 
```

### institutionCode

```{r}
taxon %<>% mutate(institutionCode = "")
```

### datasetName

```{r}
taxon %<>% mutate(datasetName = "") 
```

LR: aangeven dat dit de termen zijn die specifiek zijn voor de taxon core / taxon informatie:

Eventueel tools aanrijken voor inspectie van de data:

```{r}
taxon %>% distinct(raw_kingdom)
```

LR: of als je wilt weten hoeveel waarnemingen er zijn voor een specifieke groep:

```{r}
taxon %>% select(raw_kingdom) %>% group_by_all() %>% summarize(records = n())
```

### taxonID

```{r}
taxon %<>% mutate(taxonID = raw_taxon_id) 
```

### scientificName

```{r}
taxon %<>% mutate(scientificName = raw_scientific_name) 
```

### kingdom

```{r}
taxon %<>% mutate(kingdom = raw_kingdom) 
```

### taxonRank

Add taxonRank information
LR: Opgelet, parsenames werkt puur op syntactical rules --> zie issue, beetje riskant mss?

```{r}
parsenames(taxon $ raw_scientific_name)
```

Add taxonRank information in rankmarker to dataset:

```{r}
taxon %<>% left_join(
  select(parsenames(taxon $ scientificName), c(scientificname, rankmarker)),
  by = c("scientificName" = "scientificname"))
```

Inspect information in taxonRank:

```{r}
taxon %>% distinct(rankmarker)
```

Recode rankmarker information into `taxonRank`:

```{r}
taxon %<>% mutate(taxonRank = recode(rankmarker,
   "sp." = "species",
   "var." = "variety",
   "infrasp." = "infraspecies")) 
```

### nomenclaturalCode

```{r}
taxon %<>% mutate(nomenclaturalCode = "") 
```

## Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("raw_"))
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write.csv(taxon, file = "../data/processed/taxon.csv", na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create distribution extension

```{r}
distribution <- raw_data
```

## Term mapping 

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### taxonID

```{r}
distribution %<>% mutate(taxonID = raw_taxon_id) 
```

### locality

Inspect values:

```{r}
distribution %>% 
  select(raw_locality, raw_country_code) %>% 
  group_by_all() %>% 
  summarize(records = n())
```

Use `case_when` in this case.
When `raw_locality` is empty, use country as a locality:

```{r}
distribution %<>% mutate(locality = case_when(
  is.na(raw_locality) & raw_country_code == "BE" ~ "Belgium",
  is.na(raw_locality) & raw_country_code == "FR" ~ "France",
  is.na(raw_locality) & raw_country_code == "MK" ~ "Macedonia",
  is.na(raw_locality) & raw_country_code == "NL" ~ "The Netherlands",
  TRUE ~ raw_locality))
```

LR: eventueel de optie geven om nieuw gemapte waarden te inspecteren:

```{r}
distribution %>% 
  select(raw_locality, raw_country_code, locality) %>% 
  group_by_all() %>% 
  summarize(records = n())
```

### countryCode

```{r}
distribution %<>% mutate(countryCode = raw_country_code) 
```

### occurrenceStatus

```{r}
distribution %<>% mutate(occurrenceStatus = raw_occurrence_status) 
```

### threatStatus

recode threatStatus:

```{r}
distribution %<>% mutate(threatStatus = recode(raw_threat_status,
  "endangered" = "EN",
  "vulnerable" = "VU"))
```

### source

```{r}
distribution %<>% mutate(source = raw_source) 
```

### occurrenceRemarks

```{r}
distribution %<>% mutate(occurrenceRemarks = raw_remarks) 
```

## Post-processing

Remove the original columns:

```{r}
distribution %<>% select(-starts_with("raw_"))
```

Preview data:

```{r}
distribution %>% head()
```

Save to CSV:

```{r}
write.csv(taxon, file = "../data/processed/taxon.csv", na = "", row.names = FALSE, fileEncoding = "UTF-8")
```




