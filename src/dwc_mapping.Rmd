---
title: "Darwin Core checklist mapping"
subtitle: "For: Checklist title"
author:
- author_1
- author_2
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

# General setup 

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse)       # To transform data
library(magrittr)        # For %<>% pipes
library(janitor)         # To clean input data
library(readxl)          # To read Excel files
library(digest)          # To generate hashes
library(rgbif)
library(stringi)
```

# Read raw data

Create a data frame `raw_data` from the source data `checklist.xlsx`:

```{r}
raw_data <- read_excel(path = "../data/raw/checklist.xlsx") 
```

# Preprocess raw data

## Data structure

```{r}
raw_data %<>%
  remove_empty("rows") %>%       # Remove empty rows
  clean_names()                  # Have sensible (lowercase) column names
```

Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```

## Preview data

```{r}
raw_data %>% head(n = 5)
```

## Scientific names

### Apply nameparser

```{r}
parsed_names <- rgbif::parsenames(unique(raw_data $ raw_scientific_name)) 
```

One criterium for clean scientific names is that:
- type = SCIENTIFIC
- parsed = TRUE
- parsedpartially = FALSE

```{r}
parsed_names %>%
  select(scientificname, type, parsed, parsedpartially, rankmarker) %>% 
  filter(!(type == "SCIENTIFIC" & parsed == "TRUE" & parsedpartially == "FALSE")) 
```

So those scientific names require some inspection. It is important to notice that some unclean scientific names could be traced using the nameparser and not all the listed scientific names above are wrong. This is just a method 

### Add taxonRank information

The nameparser function also provides information about the rank of the taxon (in `rankmarker`). We extract this information here and add it to the checklist. These names need some cleaning but this will be done further in the Taxon Core mapping.

```{r}
raw_data %<>% left_join(
  select(parsed_names, scientificname, rankmarker),
  by = c("raw_scientific_name" = "scientificname")) %>% 
  rename(raw_rankmarker = rankmarker)
```

### Generate taxonID

```{r}

vdigest <- Vectorize(digest)  # Vectorize digest function to generate `taxonID`:

raw_data %<>% mutate(raw_taxon_id = paste(
  "dataset_shortname", 
  "taxon", 
  vdigest(paste(
    raw_scientific_name, raw_kingdom),  
  algo="md5"), sep=":"))
```

### Preview data

** Needs to be completed**

```{r}
raw_data %>% select(raw_kingdom, raw_rankmarker, raw_scientific_name) %>% 
  group_by_all() %>% 
  count(raw_scientific_name)
```

# Create taxon core

Remove duplicated taxa and save as a new dataframe `taxon`:

```{r}
taxon <- raw_data %>% slice(which(duplicated(raw_data $ raw_taxon_id) == "FALSE")) 
```

## Term mapping
 
Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

The following terms are record-level terms (i.e. metadata):

### language

```{r}
taxon %<>% mutate(language = "this_is_a_language") 
```

### license

```{r}
taxon %<>% mutate(license = "this_is_the_license") 
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "this_is_the_rightsHOlder") 
```

### accessRights

```{r}
taxon %<>% mutate(accessRights = "these_are_the_accessRights") 
```

### datasetID

```{r}
taxon %<>% mutate(datasetID = "this_is_the_datasetID") 
```

### institutionCode

```{r}
taxon %<>% mutate(institutionCode = "this_is_the_institutionCode")
```

### datasetName

```{r}
taxon %<>% mutate(datasetName = "this_is_the_datasetName") 
```

The following terms are specific for the taxon information:

### taxonID

```{r}
taxon %<>% mutate(taxonID = raw_taxon_id) 
```

### scientificName

```{r}
taxon %<>% mutate(scientificName = raw_scientific_name) 
```

### kingdom

```{r}
taxon %<>% mutate(kingdom = raw_kingdom) 
```

### taxonRank

Overview of the content of `raw_rankmarker`:

```{r}
taxon %>% 
  select(raw_rankmarker) %>% 
  group_by_all() %>% 
  summarize(records =  n())
```

Recode rankmarker information to match GBIF vocabulary:

```{r}
taxon %<>% mutate(taxonRank = recode(raw_rankmarker,
  "agg." = "speciesAggregate",
  "infrasp." = "infraspecificname",
  "sp." = "species",
  "var." = "variety",
  .missing = ""))
```

### nomenclaturalCode

```{r}
taxon %<>% mutate(nomenclaturalCode = "this_is_the_nomenclaturalCode") 
```

## Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("raw_"))
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write.csv(taxon, file = "../data/processed/taxon.csv", na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create distribution extension

```{r}
distribution <- raw_data
```

## Term mapping 

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### taxonID

```{r}
distribution %<>% mutate(taxonID = raw_taxon_id) 
```

### locality

Inspect values:

```{r}
distribution %>% 
  select(raw_locality, raw_country_code) %>% 
  group_by_all() %>% 
  summarize(records = n())
```

Use `case_when` in this case.
When `raw_locality` is empty, use country as a locality:

```{r}
distribution %<>% mutate(locality = case_when(
  is.na(raw_locality) & raw_country_code == "BE" ~ "Belgium",
  is.na(raw_locality) & raw_country_code == "FR" ~ "France",
  is.na(raw_locality) & raw_country_code == "MK" ~ "Macedonia",
  is.na(raw_locality) & raw_country_code == "NL" ~ "The Netherlands",
  TRUE ~ raw_locality))
```

Inspect mapped values: 

```{r}
distribution %>% 
  select(raw_locality, raw_country_code, locality) %>% 
  group_by_all() %>% 
  summarize(records = n())
```

### countryCode

```{r}
distribution %<>% mutate(countryCode = raw_country_code) 
```

### occurrenceStatus

```{r}
distribution %<>% mutate(occurrenceStatus = raw_occurrence_status) 
```

### threatStatus

recode threatStatus:

```{r}
distribution %<>% mutate(threatStatus = recode(raw_threat_status,
  "endangered" = "EN",
  "vulnerable" = "VU"))
```

### source

```{r}
distribution %<>% mutate(source = raw_source) 
```

### occurrenceRemarks

```{r}
distribution %<>% mutate(occurrenceRemarks = raw_remarks) 
```

## Post-processing

Remove the original columns:

```{r}
distribution %<>% select(-starts_with("raw_"))
```

Preview data:

```{r}
distribution %>% head()
```

Save to CSV:

```{r}
write.csv(taxon, file = "../data/processed/taxon.csv", na = "", row.names = FALSE, fileEncoding = "UTF-8")
```




