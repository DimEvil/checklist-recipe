---
title: "Darwin Core checklist mapping"
subtitle: "For: Checklist title"
author:
- author_1
- author_2
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

# General setup 

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Use UTF-8 character encoding:
LR: Hier verschillende codering voor verschillende OS geven:

```{r}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Install all required packages:
LR: dit klopt waarschijnlijk nog niet

Load libraries:

```{r}
library(tidyverse)       # To transform data
library(magrittr)        # For %<>% pipes
library(janitor)         # To clean input data
library(readxl)          # To read Excel files
library(digest)          # To generate hashes
library(rgbif)
library(inborutils) 
library(stringi)
```

Vectorize digest function to generate `taxonID`:
LR: dit eventueel onzichtbaar zetten

```{r}
vdigest <- Vectorize(digest)
```


# Read and pre-process raw data

Create a data frame `raw_data` from the source data:

```{r}
raw_data <- read_excel(path = "../data/raw/checklist.xlsx") 
```

Generate taxon_ID:
LR: zal er vanaf hangen of er een taxonID nodig is of niet --> houden we hier rekening mee?

```{r}
raw_data %<>% mutate(taxon_id = paste("dataset_shortname", "taxon", vdigest(scientific_name, algo="md5"), sep=":"))
```


```{r}
raw_data %>% View()
```

Basic cleaning steps:
LR: uitleggen in richtlijnen dat deze stap een extra cleaning step is, maar dat je basisdata in de template dus eigenlijk al clean moet zijn. 

```{r}
raw_data %<>%
  remove_empty("rows") %>%       # Remove empty rows
  clean_names()                  # Have sensible (lowercase) column names
```

Andere tools aan te rijken: eventueel verwijderen van dubbele spaties?


```{r}
raw_data %<>% mutate(taxon_id = paste(
  "dataset_shortname", 
  "taxon", 
  vdigest(paste(
    scientific_name, kingdom),  
  algo="md5"), sep=":"))
```

Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```

# Create taxon core

```{r}
taxon <- raw_data
```

## Pre-processing

Check for duplicates:

```{r}
duplicates <- taxon %>%  
  slice(which(duplicated(taxon $ raw_scientific_name) == "TRUE")) %>% 
  select(raw_scientific_name) 
```

```{r, echo=FALSE}
duplicates
```

Should contain zero rows.
If not: inspect dataset for more information on these species:

```{r}
taxon %>% filter(raw_scientific_name %in% duplicates $ raw_scientific_name)
```

The difference should be in the `locality` information.
LR: Wanneer de gedupliceerde scientific names verschillen in hun taxonomische/classificatie informatie: beiden worden gehouden in de taxon core. De taxonID moet wel verschillen tussen beide taxa, maar daarmee werd rekening gehouden bij het genereren van de taxonID (is op basis van scientific name en kingdom). Als de gedupliceerde taxa enkel verschillen in hun distributie informatie, dan kunnen we 1 van die records verwijderen in de taxon core.  

Remove duplicated rows:

```{r}
taxon %<>% slice(which(duplicated(taxon $ raw_scientific_name)==FALSE))
```

LR: wat als er andere informatie verschilt, i.e. in het geval van hemihomonymen? Dan eventueel een combinatie maken van de taxon naam en de factor waar beiden in verschillen. Dit ofwel integreren in de begeleidende tekst ofwel in een afzonderlijk script


## Term mapping
 
Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

### language

```{r}
taxon %<>% mutate(language = "") 
```

### license

```{r}
taxon %<>% mutate(license = "") 
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "") 
```

### accessRights

```{r}
taxon %<>% mutate(accessRights = "") 
```

### datasetID

```{r}
taxon %<>% mutate(datasetID = "") 
```

### institutionCode

```{r}
taxon %<>% mutate(institutionCode = "")
```

### datasetName

```{r}
taxon %<>% mutate(datasetName = "") 
```

### taxonID

```{r}
taxon %<>% mutate(taxonID = raw_taxon_id) 
```

### scientificName

```{r}
taxon %<>% mutate(scientificName = raw_scientific_name) 
```

### kingdom

```{r}
taxon %<>% mutate(kingdom = raw_kingdom) 
```

### taxonRank

Add taxonRank information
LR: Opgelet, parsenames werkt puur op syntactical rules --> zie issue, beetje riskant mss?

```{r}
parsenames(taxon $ raw_scientific_name)
```

Add taxonRank information in rankmarker to dataset:

```{r}
taxon %<>% left_join(
  select(parsenames(taxon $ scientificName), c(scientificname, rankmarker)),
  by = c("scientificName" = "scientificname"))
```

Inspect information in taxonRank:

```{r}
taxon %>% distinct(rankmarker)
```

Recode rankmarker information into `taxonRank`:

```{r}
taxon %<>% mutate(taxonRank = recode(rankmarker,
   "sp." = "species",
   "var." = "variety",
   "infrasp." = "infraspecies")) 
```

### nomenclaturalCode

```{r}
taxon %<>% mutate(nomenclaturalCode = "") 
```

## Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("raw_"))
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write.csv(taxon, file = "../data/processed/taxon.csv", na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create distribution extension

```{r}
distribution <- raw_data
```

## Term mapping 

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### taxonID

```{r}
distribution %<>% mutate(taxonID = raw_taxon_id) 
```

### locality

```{r}
distribution %<>% mutate(locality = raw_locality)
```

### countryCode

```{r}
distribution %<>% mutate(countryCode = raw_country_code) 
```

### occurrenceStatus

```{r}
distribution %<>% mutate(occurrenceStatus = raw_occurrence_status) 
```

### threatStatus

LR: hier eventueel een recode waar de volledige waarden worden vertaald naar de afkortingen?

```{r}
distribution %<>% mutate(threatStatus = raw_threat_status) 
```

### source

```{r}
distribution %<>% mutate(source = raw_source) 
```

### occurrenceRemarks

```{r}
distribution %<>% mutate(occurrenceRemarks = raw_remarks) 
```

## Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("raw_"))
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write.csv(taxon, file = "../data/processed/taxon.csv", na = "", row.names = FALSE, fileEncoding = "UTF-8")
```




